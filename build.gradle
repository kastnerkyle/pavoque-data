buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath group: 'org.yaml', name: 'snakeyaml', version: '1.17'
        classpath group: 'com.xlson.groovycsv', name: 'groovycsv', version: '1.1'
    }
}

plugins {
    id 'base'
}

import org.yaml.snakeyaml.DumperOptions
import org.yaml.snakeyaml.Yaml
import com.xlson.groovycsv.CsvParser

group 'de.dfki.mary'
version '0.2-SNAPSHOT'
description 'The PAVOQUE corpus of expressive speech'

ext {
    styles = ['angry', 'happy', 'neutral', 'poker', 'sad']
    yamlFiles = (styles + ['outtakes']).collect { file("pavoque-${it}.yaml") }
}

subprojects {
    apply plugin: 'base'

    repositories {
        ivy {
            url 'http://mary.dfki.de/download/pavoque-data'
            layout 'pattern', {
                artifact 'Recordings/[artifact].[ext]'
            }
        }
    }

    dependencies {
        'default' name: project.name, ext: 'tar'
    }

    task download(type: Copy) {
        from configurations.default
        into "$rootDir/Recordings"
        rename { "${project.name}.tar" }
    }
}

task yaml << {
    def yaml = new Yaml()
    def offsets = [:]
    CsvParser.parseCsv([separator: '\t'], file('pavoque-outtakes.tsv').newReader()).each { row ->
        offsets[row.rowLabel] = [start: row.Start.toFloat(), end: row.End.toFloat()]
    }
    def options = new DumperOptions()
    options.defaultFlowStyle = DumperOptions.FlowStyle.BLOCK
    new Yaml(options).dump(yaml.load(file('pavoque-outtakes.yaml').newReader()).each { utterance ->
        utterance.start = offsets[utterance.prompt].start
        utterance.end = offsets[utterance.prompt].end
    }, file('pavoque-outtakes.yaml').newWriter())
    def stylemap = [
            Neutral: 'neutral',
            Poker  : 'poker',
            Poppy  : 'happy',
            Obadiah: 'sad',
            Spike  : 'angry'
    ]
    def data = []
    yamlFiles.findAll { it.name != 'pavoque-outtakes.yaml' }.each { yamlFile ->
        data += yaml.load(yamlFile.newReader())
    }
    styles.each { style ->
        CsvParser.parseCsv([separator: '\t'], file("pavoque-${style}.tsv").newReader()).each { row ->
            def utterance = data.find { it.prompt == row.rowLabel && it.style == style }
            utterance.start = row.Start.toFloat()
            utterance.end = row.End.toFloat()
        }
    }
    file('ManualLabels').eachDir { dir ->
        dir.eachFileMatch(~/.*.lab/) { file ->
            def prompt = file.name - '.lab'
            def style = stylemap[dir.name]
            def start = 0
            def lines = []
            def header = true
            file.eachLine { line ->
                switch (line) {
                    case ~/^#/:
                        header = false
                        break
                    default:
                        if (!header) {
                            lines << line
                        }
                        break
                }
            }
            def segments = lines.collect { line ->
                def fields = line.trim().split(/\s+/)
                def label = fields.length < 3 ? '' : fields.drop(2).join('')
                def end = fields.first().toFloat()
                [lab: label, end: end]
            }
            data.find { it.prompt == prompt && it.style == style }.segments = segments
        }
    }
    styles.each { style ->
        yaml.dump(data.findAll { it.style == style }, file("pavoque-${style}.yaml").newWriter())
    }
}

task text {
    def textDir = file("$buildDir/text")
    group 'Build'
    description "Extract utterance text as text files into $textDir"
    inputs.files yamlFiles
    outputs.dir textDir
    doFirst {
        textDir.mkdirs()
    }
    doLast {
        yamlFiles.each { yamlFile ->
            new Yaml().load(yamlFile.newReader()).each { utterance ->
                file("$textDir/${utterance.prompt - ~/[a-z]$/}.txt").text = utterance.text
            }
        }
    }
}

task lab {
    def labDir = file("$buildDir/lab")
    group 'Build'
    description "Extract segments as Xwaves label files into $labDir"
    inputs.files yamlFiles
    outputs.dir labDir
    def stylemap = [
            neutral: 'Neutral',
            poker  : 'Poker',
            happy  : 'Poppy',
            sad    : 'Obadiah',
            angry  : 'Spike'
    ]
    doFirst {
        stylemap.values().each {
            file("$labDir/${it}").mkdirs()
        }
    }
    doLast {
        yamlFiles.each { yamlFile ->
            new Yaml().load(yamlFile.newReader()).each { utterance ->
                if (utterance.segments) {
                    file("$labDir/${stylemap[yamlFile.name - 'pavoque-' - '.yaml']}/${utterance.prompt - ~/[a-z]$/}.lab").withWriter { lab ->
                        lab.println '#'
                        utterance.segments.each { segment ->
                            lab.println sprintf("    %s  125 %s", segment.end, segment.lab)
                        }
                    }
                }
            }
        }
    }
}

task wav {
    def wavDir = file("$buildDir/wav")
    group 'Build'
    description "Extract audio as WAV files into $wavDir"
    inputs.files yamlFiles
    outputs.dir wavDir
    def stylemap = [
            neutral: 'Neutral',
            poker  : 'Poker',
            happy  : 'Poppy',
            sad    : 'Obadiah',
            angry  : 'Spike'
    ]
    doFirst {
        stylemap.values().each {
            file("$wavDir/${it}").mkdirs()
        }
    }
    doLast {
        yamlFiles.each { yamlFile ->
            new Yaml().load(yamlFile.newReader()).each { utterance ->
                exec {
                    commandLine 'sox',
                            file("${yamlFile.name - '.yaml' + '.flac'}"),
                            file("$wavDir/${stylemap[utterance.style]}/${utterance.prompt}.wav"),
                            'trim',
                            utterance.start,
                            '=' + utterance.end
                }
            }
        }
    }
}
